<!DOCTYPE html>
<html>
<head>
    <title>3D Rubik's Cube - Final, Intuitive Control Version</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">

    <style>
        /* --- CSS --- */
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(45deg, #f0f2f5, #e6e9ed);
            color: #333333;
            margin: 0;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #container {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: none;
        }

        .overlay > * {
            pointer-events: all;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .button {
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(0, 0, 0, 0.15);
            color: #333333;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 15px 35px;
            font-size: 20px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .button:hover {
            background: #ffffff;
            border-color: rgba(0, 0, 0, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .button.hidden, #timer.hidden {
            opacity: 0;
            transform: scale(0.7);
            pointer-events: none;
        }

        #timer {
            position: absolute;
            top: 40px;
            font-size: 5vw;
            font-weight: 300;
            letter-spacing: 4px;
            color: #444444;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            #timer {
                font-size: 64px;
            }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="container"></div>
    <div class="overlay">
        <div id="timer" class="hidden">00:00</div>
        <button id="shuffleButton" class="button">Shuffle</button>
        <button id="playButton" class="button hidden">Play</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let cubeGroup, highlightMesh;
        let cubies = [];

        const CUBIE_SIZE = 1;
        const CUBIE_SPACING = 0.1;

        const colors = {
            up: 0xffffff, right: 0x0045ad, front: 0xb90000,
            down: 0xffd500, left: 0x009b48, back: 0xff5900,
            core: '#3d3d3d'
        };

        let isShuffling = false, isPlaying = false, isRotating = false;
        let timerInterval, seconds = 0;

        const shuffleButton = document.getElementById('shuffleButton');
        const playButton = document.getElementById('playButton');
        const timerDisplay = document.getElementById('timer');

        const DEFAULT_CAM_POS = new THREE.Vector3(5.5, 4.5, 5.5);
        const SHUFFLE_CAM_POS = new THREE.Vector3(4, 3.5, 4);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(DEFAULT_CAM_POS);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 4;
            controls.maxDistance = 20;
            controls.enablePan = false;

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            createCube();
            createHighlightMesh();

            shuffleButton.addEventListener('click', startShuffleAnimation);
            playButton.addEventListener('click', startGame);
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousemove', onHover);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
			// We need a mousemove listener on the whole window for dragging
            window.addEventListener('mousemove', handleDrag, false);

            animate();
        }

        function createCube() {
            cubeGroup = new THREE.Group();
            const geometry = new THREE.BoxGeometry(CUBIE_SIZE, CUBIE_SIZE, CUBIE_SIZE);

            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue;
                        const materials = [
                            new THREE.MeshStandardMaterial({ color: (x === 1) ? colors.right : colors.core, roughness: 0.3, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: (x === -1) ? colors.left : colors.core, roughness: 0.3, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: (y === 1) ? colors.up : colors.core, roughness: 0.3, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: (y === -1) ? colors.down : colors.core, roughness: 0.3, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: (z === 1) ? colors.front : colors.core, roughness: 0.3, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: (z === -1) ? colors.back : colors.core, roughness: 0.3, metalness: 0.1 })
                        ];
                        const cubie = new THREE.Mesh(geometry, materials);
                        const offset = (CUBIE_SIZE + CUBIE_SPACING);
                        cubie.position.set(x * offset, y * offset, z * offset);
                        cubie.userData.initialPosition = cubie.position.clone();
                        cubie.userData.initialQuaternion = cubie.quaternion.clone();
                        cubeGroup.add(cubie);
                        cubies.push(cubie);
                    }
                }
            }
            scene.add(cubeGroup);
        }

        function createHighlightMesh() {
            const highlightGeometry = new THREE.PlaneGeometry(CUBIE_SIZE, CUBIE_SIZE);
            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlightMesh.visible = false;
            scene.add(highlightMesh);
        }

        // --- UPDATED MOUSE INTERACTION LOGIC ---

        let dragState = {
            isDragging: false,
            moveInitiated: false,
            startCoords: new THREE.Vector2(),
            intersect: null,
            dragPlane: new THREE.Plane(),
            startPoint3D: new THREE.Vector3()
        };

        function onHover(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseDown(event) {
            if (isRotating || !isPlaying || isShuffling) return;

            const intersect = getIntersection();
            if (!intersect) return; 

            controls.enabled = false;
            dragState.isDragging = true;
            dragState.moveInitiated = false;
            dragState.startCoords.set(event.clientX, event.clientY);
            dragState.intersect = intersect;

            const worldNormal = intersect.face.normal.clone().applyQuaternion(intersect.object.quaternion).normalize();
            dragState.dragPlane.setFromNormalAndCoplanarPoint(worldNormal, intersect.point);
            dragState.startPoint3D.copy(intersect.point);
        }
        
        function onMouseUp(event) {
            if (!dragState.isDragging) return;
            dragState.isDragging = false;
            controls.enabled = true;
        }

        function handleDrag(event) {
            if (!dragState.isDragging || dragState.moveInitiated || !dragState.intersect) return;

            const currentCoords = new THREE.Vector2(event.clientX, event.clientY);
            const screenDragVector = new THREE.Vector2().subVectors(currentCoords, dragState.startCoords);

            if (screenDragVector.length() > 15) { 
                dragState.moveInitiated = true;
                highlightMesh.visible = false; 

                raycaster.setFromCamera(mouse, camera);
                const dragEndPoint3D = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(dragState.dragPlane, dragEndPoint3D)) {
                    const dragVector3D = new THREE.Vector3().subVectors(dragEndPoint3D, dragState.startPoint3D);
                    const { axis, direction } = getRotationInfo(dragVector3D, dragState.dragPlane.normal);

                    if (axis) {
                        const clickedCubiePos = dragState.intersect.object.getWorldPosition(new THREE.Vector3());
                        const offset = CUBIE_SIZE + CUBIE_SPACING;
                        const layerIndex = Math.round(clickedCubiePos[axis] / offset);
                        rotateLayer(axis, layerIndex, direction, 250);
                    }
                }
            }
        }
        
        function getRotationInfo(dragVector, faceNormal) {
            const rotationAxis = new THREE.Vector3().crossVectors(dragVector, faceNormal).normalize();

            const dominantAxisVal = Math.max(Math.abs(rotationAxis.x), Math.abs(rotationAxis.y), Math.abs(rotationAxis.z));
            let axisName;
            if (dominantAxisVal === Math.abs(rotationAxis.x)) {
                axisName = 'x';
            } else if (dominantAxisVal === Math.abs(rotationAxis.y)) {
                axisName = 'y';
            } else {
                axisName = 'z';
            }
            
            const worldAxis = new THREE.Vector3();
            worldAxis[axisName] = 1;
            const direction = Math.sign(rotationAxis.dot(worldAxis));

            if (direction === 0) return { axis: null, direction: 0 };
            return { axis: axisName, direction };
        }

        function getIntersection() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubies);
            return intersects.length > 0 ? intersects[0] : null;
        }

        // --- CORE ANIMATION & GAME LOGIC ---

        function rotateLayer(axis, layerIndex, direction, duration, onComplete) {
            if (isRotating || direction === 0 || !axis) { if (onComplete) onComplete(); return; }
            
            isRotating = true;
            const pivot = new THREE.Object3D();
            scene.add(pivot);
            const layer = [];
            const offset = CUBIE_SIZE + CUBIE_SPACING;
            const axisVector = new THREE.Vector3();
            axisVector[axis] = 1;

            cubies.forEach(c => {
                const worldPos = c.getWorldPosition(new THREE.Vector3());
                if (Math.abs(worldPos.dot(axisVector) - (layerIndex * offset)) < 0.01) {
                    layer.push(c);
                }
            });

            if (layer.length === 0) {
                 isRotating = false;
                 if (onComplete) onComplete();
                 return;
            }
            
            layer.forEach(c => pivot.attach(c));
            
            const startQuaternion = pivot.quaternion.clone();
            const targetQuaternion = new THREE.Quaternion().setFromAxisAngle(axisVector, -direction * Math.PI / 2);
            let startTime = null;

            function anim(time) {
                if (startTime === null) startTime = time;
                const t = Math.min((time - startTime) / duration, 1);
                pivot.quaternion.copy(startQuaternion).slerp(targetQuaternion, t);
                if (t < 1) {
                    requestAnimationFrame(anim);
                } else {
                    pivot.quaternion.copy(targetQuaternion);
                    pivot.updateMatrixWorld();
                    layer.forEach(c => cubeGroup.attach(c));
                    scene.remove(pivot);
                    isRotating = false;
                    if (isPlaying && checkSolved()) {
                        stopTimer();
                        isPlaying = false;
                        timerDisplay.classList.add('hidden');
                        shuffleButton.classList.remove('hidden');
                        setTimeout(() => alert(`Solved in ${timerDisplay.textContent}!`), 100);
                    }
                    if (onComplete) onComplete();
                }
            }
            requestAnimationFrame(anim);
        }
        
        function checkSolved() {
            const epsilon = 0.1;
            for (const cubie of cubies) {
                const worldPos = cubie.getWorldPosition(new THREE.Vector3());
                if (worldPos.distanceTo(cubie.userData.initialPosition) > epsilon) return false;
            }
            return true;
        }

        function startShuffleAnimation() {
            if (isShuffling) return;
            resetCubeState();
            isShuffling = true;
            shuffleButton.classList.add('hidden');
            controls.enabled = false;

            animateCamera(SHUFFLE_CAM_POS, 800, () => {
                const shuffleMoves = Math.floor(Math.random() * 21) + 25;
                let moveCount = 0;
                const executeMove = () => {
                    if (moveCount >= shuffleMoves) {
                        animateCamera(DEFAULT_CAM_POS, 800, () => {
                            isShuffling = false;
                            controls.enabled = true;
                            playButton.classList.remove('hidden');
                        });
                        return;
                    }
                    const axes = ['x', 'y', 'z'];
                    const axis = axes[Math.floor(Math.random() * axes.length)];
                    const layerIndex = Math.floor(Math.random() * 3) - 1;
                    const direction = Math.random() < 0.5 ? 1 : -1;
                    rotateLayer(axis, layerIndex, direction, 100, executeMove);
                    moveCount++;
                };
                executeMove();
            });
        }

        // --- UTILITY FUNCTIONS ---
        function animateCamera(targetPosition, duration, onComplete) {
            const startPosition = camera.position.clone();
            let startTime = null;
            function anim(time) {
                if (startTime === null) startTime = time;
                const t = Math.min((time - startTime) / duration, 1);
                const easedT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                camera.position.lerpVectors(startPosition, targetPosition, easedT);
                if (t < 1) requestAnimationFrame(anim);
                else if (onComplete) onComplete();
            }
            requestAnimationFrame(anim);
        }

        function startGame() {
            playButton.classList.add('hidden');
            timerDisplay.classList.remove('hidden');
            isPlaying = true;
            startTimer();
        }

        function startTimer() {
            seconds = 0;
            updateTimerDisplay();
            timerInterval = setInterval(() => { seconds++; updateTimerDisplay(); }, 1000);
        }

        function stopTimer() { clearInterval(timerInterval); }

        function updateTimerDisplay() {
            const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = (seconds % 60).toString().padStart(2, '0');
            timerDisplay.textContent = `${minutes}:${secs}`;
        }

        function resetCubeState() {
            cubies.forEach(cubie => {
                cubeGroup.attach(cubie);
                cubie.position.copy(cubie.userData.initialPosition);
                cubie.quaternion.copy(cubie.userData.initialQuaternion);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Handle hover highlighting
            if (!dragState.isDragging && isPlaying) {
                const intersect = getIntersection();
                if (intersect) {
                    const { object, face } = intersect;
                    const worldPos = object.getWorldPosition(new THREE.Vector3());
                    const worldNormal = face.normal.clone().applyQuaternion(object.quaternion).normalize();
                    
                    highlightMesh.position.copy(worldPos).add(worldNormal.multiplyScalar(0.01));
                    highlightMesh.lookAt(worldPos.add(worldNormal));
                    highlightMesh.visible = true;
                } else {
                    highlightMesh.visible = false;
                }
            } else {
                 highlightMesh.visible = false;
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>